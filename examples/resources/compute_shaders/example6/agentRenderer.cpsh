#version 430 core

#define PI 3.14159265358979

layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba16f, binding = 0, location = 0) uniform image2D img_output;

uniform vec3 invocation_dimensions=vec3(0);
uniform vec2 image_size=vec2(0);
uniform float turnAngleMultiplier=1;

layout (std140) buffer balls_buffer {
	vec4 balls[];
};

float rand(float fli) {
	uint i=uint(fli);
	i^=2747636419u;
	i*=2654435769u;
	i^=i>>16;
	i*=2654435769u;
	i^=i>>16;
	i*=2654435769u;
	return fract(float(i)/4294967295.0);
}

void main() {
	ivec3 coords=ivec3(gl_GlobalInvocationID.xyz);
	ivec2 pixel_coords=ivec2(balls[coords.x].xy);
	
	bool hitWall=((balls[coords.x].x>=image_size.x) || (balls[coords.x].x<=0)) || ((balls[coords.x].y>=image_size.y) || (balls[coords.x].y<=0));
//	balls[coords.x]=vec4(
//		balls[coords.x].x + int(balls[coords.x].x>=image_size.x)*(image_size.x-balls[coords.x].x) + int(balls[coords.x].x<=0)*(0-balls[coords.x].x),
//		balls[coords.x].y + int(balls[coords.x].y>=image_size.y)*(image_size.y-balls[coords.x].y) + int(balls[coords.x].y<=0)*(0-balls[coords.x].y),
//		int(hitWall)*2.0*PI*rand(269.6767*balls[coords.x].x+2.3656*balls[coords.x].y)+int(!hitWall)*balls[coords.x].z,
//		balls[coords.x].w);
	balls[coords.x]=vec4(balls[coords.x].x,balls[coords.x].y,balls[coords.x].z+(int(hitWall)*PI),balls[coords.x].w);
	vec2 offset=(balls[coords.x].w+(int(hitWall)*20.0))*vec2(cos(balls[coords.x].z),sin(balls[coords.x].z));
	balls[coords.x]=vec4(balls[coords.x].x+offset.x,balls[coords.x].y+offset.y,balls[coords.x].z,balls[coords.x].w);
	
	float sampleRadius=20.0;
	float sampleAngleDifference=radians(30.0);
	float turnAngle=radians(3.25)*turnAngleMultiplier;
	vec2 samplePointCenter=sampleRadius*vec2(cos(balls[coords.x].z+0.0),sin(balls[coords.x].z+0.0));
	vec2 samplePointPositive=sampleRadius*vec2(cos(balls[coords.x].z+sampleAngleDifference),sin(balls[coords.x].z+sampleAngleDifference));
	vec2 samplePointNegative=sampleRadius*vec2(cos(balls[coords.x].z-sampleAngleDifference),sin(balls[coords.x].z-sampleAngleDifference));
	
	samplePointCenter+=balls[coords.x].xy;
	samplePointPositive+=balls[coords.x].xy;
	samplePointNegative+=balls[coords.x].xy;
	
	ivec2 samplePointCenteri=ivec2(samplePointCenter);
	ivec2 samplePointPositivei=ivec2(samplePointPositive);
	ivec2 samplePointNegativei=ivec2(samplePointNegative);
	
	float sampleCenter=length(imageLoad(img_output, samplePointCenteri).xyz);
	float samplePositive=length(imageLoad(img_output, samplePointPositivei).xyz);
	float sampleNegative=length(imageLoad(img_output, samplePointNegativei).xyz);
	
	bool center=(sampleCenter>=samplePositive) && (sampleCenter>=sampleNegative);
	bool positive=(samplePositive>sampleCenter) && (samplePositive>sampleNegative);
	bool negative=(sampleNegative>sampleCenter) && (sampleNegative>samplePositive);
	
	float angOffset=int(positive)*turnAngle-int(negative)*turnAngle;
	
	balls[coords.x]=vec4(balls[coords.x].xy,balls[coords.x].z+angOffset,balls[coords.x].w);
	
	float v=max(max(sampleCenter,samplePositive),sampleNegative);
	vec3 prevColor=imageLoad(img_output,pixel_coords).xyz;
	imageStore(img_output, pixel_coords, vec4(prevColor+normalize(vec3(1,1,1)),1));
}